# Software Engineering 2022 Spring



[TOC]

## Chapter 1 概论

**软件工程是为了经济地获得能够在实际机器上有效运行的可靠软件而建立和使用的一系列完善的工程化原则**

### 软件工程三要素

方法：–项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计等

工具：为软件工程方法提供了自动的或半自动的软件支撑环境 。–把软件工具集成起来，建立起称之为计算机辅助软件工程(CASE)的软件开发支撑系统。CASE将各种软件工具、开发机器和一个存放开发过程信息的工程数据库组合起来形成一个软件工程环境。 

过程：将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的

–定义方法使用的顺序 

–定义要求交付的文档资料 

–定义为保证质量和适应变化所需要的管理 

–定义软件开发各个阶段完成的里程碑 

### 软件工程原则

抽象：抽取事物最基本的特性和行为，忽略非基本的细节，采用分层次抽象，自顶向下、逐层细化的办法控制软件开发过程的复杂性

信息隐蔽：将模块设计成“黑箱”，实现的细节隐藏在模块内部，不让模块的使用者直接访问。这就是信息封装，使用与实现分离的原则，使用者只能通过模块接口访问模块中封装的数据。

模块化：模块是程序中逻辑上相对独立的成分，是独立的编程单位，应有良好的接口定义。如C语言程序中的函数过程，C++语言程序中的类。模块化有助于信息隐蔽和抽象，有助于表示复杂的系统

确定性：软件开发过程中所有概念的表达应是确定的、无歧义性的、规范的。这有助于人们之间在交流时不会产生误解、遗漏，保证整个开发工作协调一致。

一致性：整个软件系统（包括程序、文档和数据）的各个模块应使用一致的概念、符号和术语。程序内部接口应保持一致。软件和硬件、操作系统的接口应保持一致。系统规格说明与系统行为应保持一致。用于形式化规格说明的公理系统应保持一致

完备性：软件系统不丢失任何重要成分，可以完全实现系统所要求功能的程度。为了保证系统的完备性，在软件开发和运行过程中需要严格的技术评审

可验证性：开发大型的软件系统需要对系统自顶向下、逐层分解。系统分解应遵循系统易于检查、测试、评审的原则，以确保系统的正确性

### 软件生命周期

![image-20220618195739725](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618195739725.png)

计划时期：问题定义、可行性研究

开发时期：需求分析、总体设计、详细设计、编码、单元测试、集成测试、确认测试、系统测试

运行时期：运行与维护

## Chapter 2 软件过程及其建模

可行性分析=》需求分析=》概要设计=》详细设计=》编码=》测试=》交付=》维护

### 过程

什么是过程？针对一个给定目标的一系列操作步骤。课本：可以将一组有序的任务称为过程，它涉及获得、约束和资源使用的一系列步骤，用于产生某种想要的输出

### 软件开发过程

   按照项目的进度、成本和质量限制，开发和维护满足用户需求的软件所必需的一组有序的软件开发活动集合。

•在按任务性质，软件开发活动可分为二种形式

**技术活动**

\- 对软件项目实施开发，产生软件产品

\- 例如，需求分析，概要设计，编码，单元测试等等

**管理活动**

\- 对软件项目中的人、产品和过程等实施管理的活动

\- 例如，制订软件项目计划，软件配置等等

![image-20220618203814259](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618203814259.png)

### 生命周期

生命周期定义：涉及产品构建的这种过程称为生命周期。因为软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此有时候把软件开发过程称为**软件生命周期**

### 软件过程模型

#### 瀑布模型

![image-20220618204902234](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618204902234.png)

#### 原型模型

#### 增量模型

#### 螺旋模型

#### 敏捷开发模型

• Extreme Programming (XP) (极限编程)

–极限编程(XP)是于1998年由Smalltalk社群中的大师级人物Kent Beck首先倡导的，是敏捷方法中最主要的流派

• Crystal （水晶法）

• SCRUM（并列争球法）

• Adaptive Software Development(ASD) (自适应软件开发)

• Feature Driven Development(FDD) (特征驱动软件开发)

• Pragmatic Programming（实用编程）

优点：

•采用简单计划策略，不需要长期计划和复杂模型，开发周期短

•在全过程采用迭代增量开发、反馈修正和反复测试的方法，能够适应用户经常变化的需求

•注重市场快速反应能力，客户前期满意度高

缺点：

•注重人员的沟通，忽略文档的重要性，若项目人员流动大太，给维护带来不少难度

•对编码人员的经验要求高，若项目存在新手比较多时，老员工比较累

适用范围

•项目经常发生变更

•高风险的项目实施

•开发人员可以参与决策

## Chapter 3 计划和项目管理

### 3.1 跟踪项目进展

活动：是项目的一部分，它在一段时间内发生

里程碑：活动的完成-某一特定的时刻，里程碑专门指定的活动的结束

前驱，工期，截止时间

**Work Breakdown Stucture** 工作分解结构

•可以把项目开发分为一连串的阶段，每一个阶段由若干步骤组成

![image-20220618151622379](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618151622379.png)

根据需求分析的结果和项目的相关要求，分解出WBS。常见的分解方法有三种：

#### 任务分解方法

•类比法

软件系统发布版本：

项目规划=》需求分析=》总体设计=》详细设计=》实现=》测试=》交付

•自顶向下法

· 自底向上法

•如果软件组织在同一应用领域做过多个类似的项目，则可以使用类比法。

•自顶向下分解的质量直接决定于分解者对项目的理解，所以要求分解者经验丰富，对项目有深入理解。

•自底向上法适用于哪些具有创新型或不太熟悉的项目，更容易发挥团队的力量。

---

#### 工作分解与活动图

–*点* *(**圈**)*  :  项目里程碑  

–*线*（框）:  包含的活动

**AOE(边活动网络)：有向图G中，若用顶点代表事件，有向边表示活动，有向边上的权值表示一项活动持续的时间，则称图G为AOE网络。**

  **AOE网络主要用于估算一项工程的完成时间。**

![image-20220618154009736](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618154009736.png)

关键路径与关键活动 

 AOE网络研究以下两个方面：

 (1)整个工程至少需要多少时间；

 (2)哪些活动是影响工程进度的关键。

 关键路径法(CMP)就是解决这类问题的方法。

 关键路径：从源点到汇点的最长路径。

 关键活动：关键路径上的活动。或对整个工程的最短完成时间有影响的活动。即如它不能按期完成就会影响整个工程。

#### 跟踪项目进展的工具

**甘特图**

### 3.2 项目人员

关键项目活动：需求分析、系统设计、程序设计、程序实现、测试、训练、维护、质量保证

交流路径：C(n,2)

项目组织：

- *民主制程序员组*: 每个人平等分担责任；小组成员完全平等，享有充分民主，通过协商做出技术决策小组成员间的通信是平行的，如果一个小组有n个成员，则可能的通信信道有n(n-1)/2条。

- *主程序员组*: 一个人总体负责系统的设计和开发：

- *现代程序员组：结合民主制程序员组和主程序员组的优点*

### 3.3 工作量估算

软件规模评估方法：

​	代码行分析法(**COCOMO模型**)、

功能点分析：通过软件运行时与外部环境的交互作用，如操作者向应用软件输入的数据、指令以及返回的信息之间的交互，也就是应用软件提供给用户的功能，来度量软件的规模。这是一种相对抽象的方法，是一种人为设计出的度量方式。主要从外部对应用软件进行定量描述。

功能点和代码行的相互转换

![image-20220618171542983](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618171542983.png)

- 代码行估算法

  确定功能：

  首先将功能反复分解，直到可以对为实现该功能所要求的源代码行数做出可靠的估算为止。然后可以给出**极好、正常和较差**三种情况下的源代码估算行数的期望值，分别用**a、m、b**表示

  极好、正常、较差三种情况下的源代码估算行数的期望值，分别用a,m,b表示

  期望值$Le = \frac{a+4m+b}{6}$ 偏差$Ld = \sqrt{\sum_{i=1}^{n}(\frac{b-a}{6})^2}$ 

  

- 专家估算法-Deiphi

  ![image-20220618171823873](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618171823873.png)

- 类比估计法

  ![image-20220618171843536](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618171843536.png)

- 静态单变量模型

- ![image-20220618172655340](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618172655340.png)

#### **COCOMO**

构造性成本模型

![image-20220618191939894](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618191939894.png)

![image-20220618191954276](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618191954276.png)

剩下的COCOMO看不懂了~



### 风险管理

![image-20220328141705857](C:\Users\12042\AppData\Roaming\Typora\typora-user-images\image-20220328141705857.png)

风险管理

- 风险评估

  - 风险识别

  - 风险分析

  - 风险优先级分配

    - 风险暴露: $风险暴露 = 风险概率 * 风险影响$，进行回归测试

      ![image-20220328143217041](C:\Users\12042\AppData\Roaming\Typora\typora-user-images\image-20220328143217041.png)

      类似于决策树分析

      进行测试对应一个概率、不进行测试对应一个概率、然后算一个组合风险暴露计算，一个期望Loss 不同

      ![image-20220328143603015](C:\Users\12042\AppData\Roaming\Typora\typora-user-images\image-20220328143603015.png)

- 风险控制

  - 风险降低 三种策略
    - 避免风险
    - 转移风险
    - 假设风险会发生: 接受并控制
    - 风险降低杠杆
  - 风险管理计划
  - 风险化解

量化风险，决策树分析

•损益期望值(Expected Monetary Value，EMV)是决策树的一种计算值，根据风险发生的概率计算

•例如：某行动方案成功的概率是50%，收益是10

​            EMV=10×50%=5



## Chapter 4 获取需求

### 4.1 需求过程-获取需求的过程

SRS 软件需求规格

![image-20220618214335965](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618214335965.png)

获取需求过程

![image-20220618214323411](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618214323411.png)

### 4.2 需求引发



### 4.3 需求类型

**功能需求**- 描述系统预期提供的功能或服务

- 对系统应提供的服务
- 如何对输入作出反应
- 系统在特定条件下的行为
- *描述方式*：文字描述、图标表示
- 功能需求描述应该完整而且一致和准确

**非功能需求** 指那些不直接与系统具体功能相关的一类需求

- 响应时间
- 易使用性
- 高可靠性
- 低维护代价
- 例如POS机，

**领域需求**

- 源于系统的应用领域需求
- 反应应用领域的基本问题，直接影响到系统的可用性
- 版权限制、

### 4.4 需求特征

- 正确性

- 一致性

- 无二义性

- 完整性

- 可行性

- 相关性

- 可测试性

- 可跟踪性

  

### 4.5 建模表示法

#### 4.5.1 ER图

四种成分

- **矩形框**：表示实体，在框中计入实体名
- **菱形框:** 表示实体和实体之间的联系框中写联系名
- **椭圆形**：表示实体或者联系的属性，把属性名写入其中
- **连线**
  - 一对一
  - 一对多：多方写N
  - 多对多：多方写N、M

构造ER图

包括如下步骤：标识实体集；标识联系集；标识属性值集；标识主属性。

> 例1：•用图书、作者两个实体及其属性和联系构建E-R图。
>
> –图书的属性：书号、书名、出版社、价格
>
> –作者的属性：身份证号、姓名、年龄
>
> ![image-20220404145216329](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404145216329.png)

#### 4.5.2 UML类图

标准建模语言UML

- UML基本图素：类、对象、包、接口
- UML模型图：按照UML建模规则构成的。例如：用例图、类图、对象图、状态图等
- UML建模规则：UML模型图必须按照特定的规则有机地组合而成，从而构成一个有机的、完整的UML模型图

##### 类图概要

- 类图以反映类的结构(属性、操作)以及类之间的关系为主要目的，描述了软件系统的结构，是一种静态建模方法

- 类图中的“类”与面向对象语言中的“类”的概念是对应的，是对现实世界中的事物的抽象

  

##### 类图解释

- 类
  - ![image-20220404155251853](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404155251853.png)
  - 从上到下分为三部分，分别是类名、属性和操作。类名是必须有的
  - 类如果有属性，则每一个属性都必须有一个名字，另外还可以有其它的描述信息，如可见性、数据类型、缺省值等
  - 类如果有操作，则每一个操作也都有一个名字，其它可选的信息包括可见性、参数的名字、参数类型、参数缺省值和操作的返回值的类型等

##### 类图中的关系

- 关联关系：描述了类的结构之间的关系。具有方向、名字、角色和多重性等信息。一般的关 联关系语义较弱。也有两种语义较强，分别是聚合与组合

  - 

- 泛化关系：在面向对象中一般称为继承关系，存在于父类与子类、父接口与子接口之间

  ![image-20220404153844605](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404153844605.png)

  ![image-20220404153928172](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404153928172.png)

  

- 实现关系：对应于类和接口之间的关系

- 依赖关系：描述了一个类的变化对依赖于它的类产生影响的情况。有多种表现形式，例如绑定(bind)、友元(friend)等。 友元就是访问私有变量的一种机制。

  - 表示方法

  ![image-20220404154022031](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404154022031.png)

  - bind

![image-20220404154440220](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404154440220.png)

​			友元			

![image-20220404154518126](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220404154518126.png)



![image-20220618214547697](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618214547697.png)

#### 4.5.5 Petri网

 任何系统都可抽象为状态（或者条件）、活动（或者事件）及其之间关系的三元结构。在Petri网中，状态用位置（place）表示，活动用迁移（transition）表示。迁移的作用是改变状态，位置的作用是决定迁移能否发生，迁移和位置之间的这种依赖关系用流来表示。

 Petri网结构---Petri网结构是一个三元组*N =*（*P*，*T*，*F*），其中，

 ① *P* = {*p*1，*p*2，…，*p*n}是有限位置集合；

 ② *T* = {*t*1，*t*2，…，*t*n}是有限迁移集合（*P* È*T* *¹* Æ，*P*Ç*T* = Æ）；

 ③ *F* Í（*P*×*T**）*È（*T*×P）为流关系。

![image-20220618215105023](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618215105023.png)

#### 4.5.6 数据流图

![image-20220618215206274](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618215206274.png)

![image-20220618215225146](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618215225146.png)

---

## Chapter 5 软件体系结构

### 设计过程

•设计是一种创造性的过程，它考虑如何实现所有客户的需求； 设计所产生的计划也称为设计

•早期的设计专注于系统的体系结构

•后续的设计专注于如何实现单个的单元

> •大部分设计工作是例程设计 (**routine design)**, 通过对相似问题的解决方案进行复用和调整来解决当前问题 hhh很真实了

**•软件体系结构也有一般性的解决方案, 称为体系结构风格**

多种理解决策以及评估选择的体系结构的工具：设计模式、设计公约、创新设计、设计原则

==概念==

体系结构Architecture:一种软件解决方案，用于解释如何将系统分解为单元， 以及单元如何相互关联，还包括这些单元的所有外部特性。

设计模式design pattern：一种针对单个软件模块或少量模块而给出的一般性解决方案，它提供较低层次的设计决策。它是一个共同的设计结构的关键方面，包括对象和实例， 角色和协作，责任分配。

设计公约Design Convention:一系列设计决策和建议的集合，用于提高系统某方面的设计质量。当一种设计公约发展成熟时，将会被封装成设计模式或体系结构风格，最后可 能被内嵌为一种程序语言结构。	

软件体系结构开发过程

![image-20220615221611926](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615221611926.png)

建模：尝试可能的分解

分析：分析初步的体系结构

文档化：记录体系结构的决策

评审：检查体系结构是否满足需求

然后形成SAD 软件体系结构文档

### 分解和视图

•流行的设计方法:

–面向功能的分解

–面向特征的分解

–面向数据的分解

–面向进程的分解

–面向事件的分解

–面向对象的设计

•当系统的每个活动都仅由对应的软件单元实现，并且每个软件单元的输入和输出都已经明确地被定义时，设计才可以说是**模块化**的

•如果一个软件单元的接口能够准确无误地指定该单元的外部可见行为，则称该软件单元是**定义明确的**

> 模块化 以及 定义明确的概念？

•常见体系结构视图:

–分解视图

–依赖视图

–泛华视图

–执行视图

–实现视图

–部署视图

–工作分配视图

### 体系结构风格

•体系结构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。

定义：软件体系结构风格是已经建立的、大规模的系统结构模式。

六种体系结构风格：

管道和过滤器、客户与服务器、对等网络、发布-订阅、信息库和分层

![image-20220617203512712](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617203512712.png)

#### 数据流风格

管道和过滤器，当输入数据经过一系列的计算和操作构件的变换形成输出数据时，可以应用这种体系结构。

管道/过滤器、批处理序列都属于数据流风格

![image-20220617203549237](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617203549237.png)

**•把系统任务分成为几个独立的功能模块。这些功能模块采用通过系统的数据流连接。**

•在管道-过滤器风格下，每个功能模块都有一组输入和输出。**功能模块称作过滤器（filters**）；功能**模块间的连接可以看作输入、输出数据流之间的通路，所以称作管道**（pipes）。

•管道-过滤器风格的**特性**之一在于过滤器的相对独立性，即过滤器独立完成自身功能，相互之间无需进行状态交互。

![image-20220617203734039](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617203734039.png)

**优点**

•设计者可以将整个系统的输入、输出特性简单的理解为各个过滤器功能的合成。

•基于管道-过滤器风格的系统具有较强的可维护性和可扩展性

•支持一些特定的分析，如吞吐量计算和死锁检测等

•管道-过滤器风格具有并发性 、

**缺点：**

•交互式处理能力弱

•具体实现比较复杂

–数据流同步问题

–数据加密与解析

编译器的管道过滤器风格

![image-20220617204259878](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617204259878.png)

#### 调用返回风格

课本没有

•层次结构风格

  **整个系统被组织成一个分层结构，每一层为上层提供服务，并作为下一层的客户。**

![image-20220617205111285](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617205111285.png)

实例：ISO网络体系结构

•优点： 

–层次结构风格支持系统设计过程中的逐级抽象

–基于层次结构风格的系统具有较好的可扩展性

–层次结构风格支持软件复用

•缺点： 

–并不是每个系统都可以很容易地划分为分层的模式

–很难找到一个合适的、正确的层次抽象方法。

#### C/S风格

•客户机/服务器（C/S）体系结构是基于资源不对等，且为实现共享而提出来的。

•C/S体系结构有三个主要组成部分：**数据库服务器、客户应用程序和网络。**

服务器提供服务，客户端通过请求应答协议访问服务

客户向服务器发送一个可执行的函数，乘坐回调callback

![image-20220617205402938](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617205402938.png)

•优点： 

–界面和操作可以很丰富

–安全性高

–响应速度快

•缺点： 

–适用面窄

–用户群固定

–维护成本高

#### BS风格

•B/S体系结构主要利用不断成熟的WWW浏览器技术，特别是浏览器嵌入的多种脚本语言

•B/S体系结构有三个主要组成部分：浏览器、 Web服务器、数据库服务器。

![image-20220617205431494](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617205431494.png)

•优点： 

–维护和升级方式简单

–交互性较强

•缺点： 

–在速度和安全性上需要花费巨大的设计成本

–通常需要刷新页面（Ajax等可以一定程度缓解该问题）

通信开销大

### 满足质量属性

•体系结构风格只能实现一般意义上良好的性质。为了保证对特定属性的支持，具体的策略将被使用:

–可修改性

–性能

–安全性

–可靠性

–健壮性

–易使用性

–商业目标

### 故障树分析

•故障树分析方法在系统可靠性分析、安全性分析和风险评价中具有重要作用和地位。既可用于定性分析又可定量分析。

•在故障树分析中，对于所研究系统的**各类故障状态或不正常工作情况统称为故障事件**。与故障事件对应的是成功事件。两者均称为事件。

•故障树是一种为研究系统某功能故障而建立的一种倒树状的逻辑因果关系图

**特点**

•是一种图形演绎法，是故障事件在一定条件下的逻辑推理方法，可针对某一故障事件，作层层追踪分析(自上而下)；

•这种图形化的方法清楚易懂，使人们对所描述的事件之间的逻辑关系一目了然，而且便于对各种事件之间复杂的逻辑关系进行深入的定性和定量分析；

•由于故障树将系统故障的各种可能因素联系起来，可有效找出系统薄弱环节和系统的故障谱，在系统设计阶段有助于判明系统的隐患和潜在故障，以便提高系统的可靠性；

•故障树可作为管理和维修人员的一个形象的管理、维修指南，可用于培训使用、维修和管理人员，可用来制订维修计划和检修排故方案

#### 步骤

 (1) 选择顶事件。据工程实际需要选择合理的顶事件

 (2) 建立故障树

 (3) 故障树的定性分析

​    a) 故障树的简化

​    b) 求最小割集

 (4) 故障树的定量分析

​    a) 求顶事件的发生概率

​    b) 重要度分析

 (5) 确定设计上的薄弱环节（找出问题所在）

 (6) 采取措施，提高产品的可靠性和安全性

常用事件和符号

![image-20220617210829719](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617210829719.png)

注意中间和顶部 是 举行

底部是圆形，其余用不太到

![image-20220617213312234](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617213312234.png)

故障树=》最小割集树 本质上就是 **逻辑表达式的运算**

![image-20220617213501066](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617213501066.png)

这个A1 G5 就是

G1 = G2 * G3 = (G4*G5) * (A4*A5) = (A1+A2 )*(G5)

故障树的定量计算

**利用最小割集计算事件发生的概率** 

![image-20220617213922923](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617213922923.png)

### SAD

•SAD 应该包含的信息:

–系统综述

–视图

–软件单元

–分析数据和结果

–设计合理性

–定义，术语表，缩写词



## Chapter 6 设计模块

### 6.1 设计原则

- 模块（module）与构件(component)
  - 模块：定义输入、输出和特性的程序实体
  - 构件：可重复使用的软件组件

**设计原则**是指把系统功能和行为分解成模块的指导方针6种重要的原则:

模块化、接口、信息隐藏、增量式开发、抽象、通用性

#### 模块化

**模块化**是一种把系统中各不相关的部分进行分离的原则，以便于各部分能够独立研究，也称为关注点分离

•如果该原则运用得当, 每个模块都有自己唯一的目的，并且相对独立于其它模块

–每个模块理解和开发会更加简单

–故障定位更加简单 (because there are fewer suspect modules per fault) 

–系统修改更加简单 (because a change to one module affects relatively few other modules

•为了确定是否很好地分离了关注点，我们使用两个概念来度量模块的独立程度：耦合度 和 内聚度

##### ==耦合度== 

**耦合**衡量不同模块彼此间互相依赖的紧密程度。

两个模块之间存在着很强的依赖关系称为**紧密耦合**，两个模块之间存在较少依赖关系称为**松散耦合**，模块之间没有任何依赖关系称为**无耦合**。耦合越松散，模块之间的联系就越小，模块的独立性就越强。

**耦合的强度依赖于以下因素：**

（1）一个模块对另一个模块的引用**

如模块A调用模块B那么模块A的功能依赖于模块B的功能

（2）传递数据

（3）施加控制

（4）接口复杂程度

###### 非直接耦合

两个模块都能独立地工作而不需要另一个的存在，这表明模块间无任何连接，耦合程度最低。

###### 数据耦合

如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。数据耦合是最简单的耦合形式，模块间耦合程度较低。

###### **标记耦合**

两个模块间传递的参数是数据结构变量，如高级语言中的数组名、记录名和文件名等，模块间的这种联系称为标记耦合。

在设计时应尽量避免或采用其它方法消除这种耦合，但有时因为其它功能的缘故，标记耦合是不可避免的。

###### 控制耦合

两个模块间传递的是**控制信息**，如开关量、标志和名字等，则这两个模块之间的耦合称为控制耦合。

###### 公共耦合

一组模块都访问同一个**公共数据环境**，则这组模块之间的耦合就称为公共耦合。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区、任何存储介质上的文件等。

如果一个模块只向公共数据环境传送数据，而另一个模块只从公共数据环境中提取数据，则这种公共耦合称为松散公共耦合，如下图a所示

如果两个模块对既往公共数据环境输送数据又从里面提取数据，则这种耦合称为紧密公共耦合，如下图b所示。

**如使用公共耦合，应尽量采用松散公共耦合**

![image-20220516141702965](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220516141702965.png)

###### 内容耦合

内容耦合是最高程度的耦合，如果发生下列情形，两模块之间就发生了内容耦合：

①一个模块直接访问另一个模块的内部数据。

②一个模块不通过正常入口转到另一模块内部。

③两个模块有一部分程序代码重叠

![image-20220617234003745](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220617234003745.png)

##### 内聚度

**内聚**是衡量**一个模块内部各个元素彼此结合的紧密程度**。一个模块内聚程度越高，说明该模块内部各元素之间的关联也就越强

###### 偶然内聚

模块内部各个元素在功能上不相关或者关系松散。

偶然内聚被认为是最差的一种内聚，其缺点是：模块不易理解，不易维护，不易重用。

###### 逻辑内聚

一个模块完成的任务在**逻辑**上属于相同或相似的一类则称为逻辑内聚。下图中被调用模块就是一个逻辑内聚模块，它根据输入的控制信息判定执行相应的功能

###### 时间内聚

一个模块包含了需要在**同一时间段**中执行的多个任务，则称该模块的内聚为时间内聚。例如，将多个变量的初始化放在同一个模块中实现。

优点：不需要选择参数，所有任务可以任意次序执行，逻辑简单。

缺点：这种模块结合了许多无关的任务，模块一旦失效，难以直接确定是哪一个任务失效。

###### 过程内聚

一个模块内的处理元素是相关的，而且必须以**特定次序执行**，则称为过程内聚。例如，在利用流程图划分模块时，如果将流程图中完成同一个处理的循环部分、判定部分、计算部分分成3个模块，则这3个模块就是过程内聚模块。

### 6.2 面向对象的设计方法

面向过程:SP

面向对象：OOP

#### 面向对象设计原则概述

![image-20220618000849378](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618000849378.png)

==**必考一个**==

![image-20220516144730495](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220516144730495.png)

##### 单一职责原则

在软件系统中，一个类只负责一个功能领域中的相应职责

就一个类而言，应该就有一个引起他变化的原因

类的职责主要包括两个方面：**数据职责和行为职责**，数据职责通过其属性来体现，而行为职责通过其方法来体现。单一职责原则是实现**高内聚、低耦合**的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

例子：

![image-20220618001730814](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618001730814.png)

![image-20220618001915247](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220618001915247.png)

##### 开闭原则

一个软件实体应当**对扩展开放，对修改关闭**。

也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。**在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类**

##### 里氏代换原则

==所有引用基类（父类）的地方必须能透明地使用其子类的对象==

在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象

##### 依赖倒转原则

–依赖倒转原则(Dependence Inversion Principle, DIP)的定义如下：

•高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

–另一种表述为：

•要针对接口编程，不要针对实现编程。

**–简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。**

##### 合成复用

尽量使用对象组合，而不是继承来达到复用的目的

##### 迪米特法则

又称为最少知识原则–它有多种定义方法，其中几种典型定义如下：

•(1) 不要和“陌生人”说话。 

•(2) 只与你的直接朋友通信。 

•(3) 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

迪米特法则就是指**一个软件实体应当尽可能少的与其他实体发生相互作用**。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。

### 6.3 面向对象设计模式

**设计模式（Design pattern）**是一套被反复使用、多数人知晓

的、经过分类编目的、代码设计经验的总结。 

为何提倡设计模式？

根本原因是为了代码复用，增加可维护性 。

设计模式有助于对框架结构的理解，成熟的框架通常使用了多

种设计模式。

•设计模式从应用的角度被分为三个大的类型 

–创建型模式

–结构型模式

行为型模式

#### 创造型设计模式

##### 单例模型

保证一个类有且仅有一个实例，提供一个全局访问点

##### 工厂方法 (Factory Method)

父类负责定义创建对象的公共接口，而子类则负责生成具体对象，将类的实例化操作延迟到子类中完成

##### 抽象工厂(Abstract Factory)

为一个产品族提供统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类

##### 建造者模式 (Builder)

将复杂对象的构建与它的表示分离，同样的构建过程可以创建不同的表示。允许用户可以只通过指定复杂对象的类型和内容就可以构建它们，用户不知道内部的具体构建细节

##### 原型模式

通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据

#### 结构型设计模式

•结构型模式讨论的是类和对象的结构，它采用继承机制来组合接口或实现（类结构型模式），或者通过组合一些对象，从而实现新的功能（对象结构型模式）

–合成（Composite）模式：定义一个接口，使之可以用于单一对象，也可以应用于多个单一对象组成的对象组

–装饰（Decorator）模式：动态给一个对象添加一些额外的职责，就好像给一个物体加上装饰物，完善其功能

–代理（Proxy）模式：在软件系统中，有些对象有时候由于跨越网络或者其他的障碍，而不能够或者不想直接访问另一个对象，如果直接访问会给系统带来不必要的复杂性，这时候可以在客户程序和目标对象之间增加一层中间层，让代理对象来代替目标对象打点一切，这就是代理（Proxy）模式

–享元（Flyweight）模式：Flyweight是一个共享对象，它可以同时在不同上下文（Context）使用

–外观（Facade）模式：外观模式为子系统提供了一个更高层次、更简单的接口，从而降低了子系统的复杂度和依赖。这使得子系统更易于使用和管理。外观承担与子系统中类交互的责任

–桥梁（Bridge）模式：桥梁模式的用意是将问题的抽象和实现分离开来实现，通过用聚合代替继承来解决子类爆炸性增长的问题

–适配器(Adapter)模式：将一个类的接口适配成用户所期待的接口。一个适配器允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包装在一个已存在的类中

#### 行为型设计模式

•着力解决的是类实体之间的通讯关系，希望以面向对象的方式描述一个控制流程

–模版方法（Template Method）：定义了一个算法步骤，并允许子类别为一个或多个步骤提供其实现方式。让子类别在不改变算法架构的情况下，重新定义算法中某些步骤

–观察者（Observer）模式：定义了对象之间一对多的依赖，当这个对象的状态发生改变的时候，多个对象会接受到通知，有机会做出反馈

–迭代子（Iterator）模式：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示

---

#### 单例模式

单例设计模式的特点：

1.单例设计模式保证一个类只有一个实例;

2.要提供一个访问该类对象实例的全局访问点。

单例模式最重要的就是要**保证一个类只有一个实例并且这个类**

**易于被访问**。 

一个全局类使得一个对象可以被访问，但是这样做却不能防止

你实例化多个对象。

1.为了避免其它程序过多的建立该类的对象，先禁止其它程序建

立该类对象实例（将构造器私有化）。

2.为了方便其它程序访问该类的对象，只好在本类中自定义一个

对象，由1可知该对象是static的，并对外提供访问方式。

饿汉式(总结)

 对象预先加载，线程是安全的，在类创建好的同时对象生成，

调用获得对象实例的方法反应速度快，代码简练。

懒汉式(总结)

 对象延迟加载，效率高，只有在使用的时候才实例化对象，若

设计不当线程会不安全，代码相对于饿汉式复杂，第一次加

载类对象的时候反应不快。

## Chapter 7 编写程序

•编程风格主要包括：

–**源程序中的内部文档**

–**数据说明**

–**语句构造**

–**输入输出**

•在源程序中的内部文档主要包括：

–**标识符的命名**

–**注解**

**程序的视觉组织**

标识符的命名、程序的注释、序言性注释、功能性注释、

## Chapter 8 测试程序

### 软件测试的特点

开销大、不能进行穷举测试

错误、故障、失效

### 软件故障和失效

#### 故障分类

算法故障：由于处理步骤中的某些错误，使得对于给定的输入、构建的算法或者逻辑没有产生适当的输出。

语法故障

计算故障和精度故障：一个公式的是显示错误的、或者计算结果没有达到要求的精度

文档故障：文档与程序实际做的事情不一致。

压力故障、过载故障

能力故障、边界故障：系统活动到达指定极限的时候，系统性能会变得不可接受

计时故障、协调故障：开发实施系统，

吞吐量故障、性能故障：系统不能以规定的速度执行

恢复故障：系统失效时，不能表现得像设计人员希望的那样进行恢复

标准和过程故障：可能并不总是会影响程序运行，但是会培育一种环境，使得参与人员达到一种共识：在测试或者修改系统的时候可能会产生故障。代码难以让他人理解以及难以理解发现解决问题的数据描述

### 测试步骤

![image-20220614214920209](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614214920209.png)

首先进行构件代码的单元测试、然后对测试的构件

- 根据设计规格说明进行集成测试，产生集成的模块
- 对集成模块按照系统功能需求进行功能测试，得到运行的系统
- 对运行的系统根据其他软件需求进行性能测试，得到验证、确认的软件
- 然后对验证、确认的软件按照客户需求规格说明进行验收测试，得到接受的系统
- 对接收的系统根据用户环境进行安装测试得到使用中的系统

#### 

### 软件测试方法

- 静态测试，程序不执行
  - 静态分析器、自动工具
  - 代码评审（人工方式）
- 动态测试，程序执行
  - 黑盒测试、测试功能
  - 白盒测试，测试结构

**动态测试方法**

通过选择适当的测试用例，执行程序。

白盒方法：分析程序的内部逻辑结构，注意选择适当的覆盖标准，设计测试用例，对主要路径进行尽可能多的测试。

黑盒法：不考虑程序的内部结构与特性，只根据程序功能或程序的外部特性设计测试用例。

测试用例：为特定目标而编制的一组测试输入、执行条件和预期结果，其目的是测试程序中的路径，核实程序或软件能否满足某个特定的需求。

#### **白盒法**

白盒法又称为逻辑覆盖法，其测试用例选择，是按照不同覆盖标准确定的。

![image-20220614220124701](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614220124701.png)

**白盒法常用的覆盖标准**

①语句覆盖：选择足够的测试用例，使得程序中每个语句至少都能被执行一次。
②判定覆盖：执行足够的测试用例，使得程序中每个判定至少都获得一次“真”值和“假”值。
③条件覆盖：执行足够的测试用例，使得判定中的每个条件获得各种可能的结果。
④判定/条件覆盖：执行足够的测试用例，使得判定中每个条件取到各种可能的值，并使每个判定取到各种可能的结果。
⑤条件组合覆盖：执行足够的例子，使得每个判定中条件的各种可能组合都至少出现一次。

**白盒法步骤：**

1）选择逻辑覆盖标准。
2）按照覆盖标准列出所有情况。
3）选择确定测试用例。
4）验证分析运行结果与预期结果。

[例子]

```bash
Procedure（VAR A，B，X：REAL）；
BEGIN
IF （A>1) AND (B=0)
THEN X:=X/A ;
IF (A=2) OR (X>1)
THEN X:=X+1
END;
```

![image-20220614220419091](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614220419091.png)

![image-20220614221454336](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614221454336.png)

#### 黑盒法

不考虑程序的内部结构与特性，只根据程序功能或程序的外部特性设计测试用例。(偏重于功能测试吗)

![image-20220614221655869](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614221655869.png)

##### **等价类划分法**

等价类划分法是一种重要的、常用的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。

![image-20220614221823363](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614221823363.png)



等价类划分是黑盒测试技术，可将测试用例数量降到最少。
等价类划分是将可能的输入划分成若干等价的类，每一个类选择一个测试用例，这种方法假设对于一个类的所有成员来说，系统通常按照类似的方式运行。
关键步骤：确定等价类和选择测试输入
基本原则：
每个可能的输入属于某一个等价类
任何输入都不会属于多个等价类
用等价类的某个成员作为输入时，如果证明执行存在误差，那么用该类的任何其他成员作为输入，也能检查到同样的误差。

划分等价类可分为两种情况：
（1）有效等价类
-是指对软件规格说明而言，是有意义的、合理的输入数据所组成的集合。利用有效等价类，能够检验程序是否实现了规格说明中预先规定的功能和性能。
（2）无效等价类
-是指对软件规格说明而言，是无意义的、不合理的输入数据所构成的集合。利用无效等价类，可以鉴别程序异常处理的情况，检查被测对象的功能和性能的实现是否有不符合规格说明要求的地方。

![image-20220614235254449](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614235254449.png)

例：程序输入x取值于一个固定的枚举类型{1,3,7,15}，且程序
中对这4个数值分别进行了处理，则有效等价类为x=1、x=3、
x=7、x=15，无效等价类为x≠1,3,7,15的值的集合。

（3）按照数值集合划分在输入条件规定了输入值的集合或规定了“必须如何”的条件下，可以确定一个有效等价类和一个无效等价类（该集合有效值之外）。

![image-20220614235930707](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220614235930707.png)

在**设计测试用例**时，应同时考虑有效等价类和无效等价类测试用例的设计。
根据已列出的等价类表可确定测试用例，具体过程如下：
（1）首先为等价类表中的每一个等价类分别规定一个唯一的编号。
（2）设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的有效等价类。重复这个步骤，直到所有的有效等价类均被测试用例所覆盖。
（3）设计一个新的测试用例，使它仅覆盖一个尚未覆盖的无效等价类。重复这一步骤，直到所有的无效等价类均被测试用例所覆盖。

**为有效等价类设计一个测试用例、每个无效等价类都设计一个**

![image-20220615000415759](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615000415759.png)

![image-20220615000421492](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615000421492.png)

##### 边界值分析法

边界值分析使用与等价类划分法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。
例：测试计算平方根的函数
-输入：实数
-输出：实数
-规格说明：当输入一个0或比0大的数的时候，返回其正平方根；当输入一个小于0的数时，显示错误信息“平方根非法-输入值小于0”并返回0。

![image-20220615001034023](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615001034023.png)

### 集成测试

> 每个模块都能单独工作，但这些模块集成在一起之后却不能正常工作；或是系统集成后虽可以正常运行，但系统的容错性、安全性以及整体性却得不到保障，系统不能长时间运行等等。这就需要进行集成测试和系统测试，以找出其中的软件缺陷，来提高整个软件的质量和可靠性。

![image-20220615001832991](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615001832991.png)

集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统进行的测试活动。

集成的基本策略比较多，分类比较复杂，但是都可以归结为以下两类：
非增量式集成策略——一步到位 Non－Incremental Testing
增量式集成策略——逐步实现 Incremental Testing

驱动模块（Driver）：用来模拟待测模块的上级模块。驱动模块在集成测试中**接受测试数据，将相关的数据传送给待测模块**，启动待测模块，并打印出相应的结果。

桩模块（Stub）：也称为存根程序，用以模拟待测模块工作过程中所调用的模块。桩模块由待测模块调用，它们一般只进行很少的数据处理，例如打印入口和返回，以便于检验待测模块与下级模块的接口。

**非增量式测试是采用一步到位的方法来构造测试：**
对所有模块进行个别的单元测试后，按照程序结构图将各模块连接起来，把连接后的程序当作一个整体进行测试。
又叫大爆炸式集成（Big Bang）

![image-20220615002709623](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615002709623.png)

**增量式测试的集成是逐步实现的：**

逐次将未曾集成测试的模块和已经集成测试的模块（或子系统）结合成程序包，再将这些模块集成为较大系统，在集成的过程中边连接边测试，以发现连接过程中产生的问题

- 自顶向下增量式测试

  从属于主控模块的按深度优先方式（纵向）或者广度优先方式（横向）集成到结构中去

  自顶向下集成测试的整个过程由3个步骤完成：
  （1）主控模块作为测试驱动器。
  （2）根据集成的方式（深度或广度），下层的桩模块一次一次地被替换为真正的模块。
  （3）在每个模块被集成时，都必须进行单元测试。
  重复第2步，直到整个系统被测试完成。

- 自底向上增量式测试

  从具有最小依赖性的底层组件开始，按照依赖关系树的结构，逐层向上集成，以检验系统的稳定性。
  最常用的集成策略，其他方法都或多或少应用此种方法。

  **测试步骤**

  •（1）起始于模块依赖关系树的底层叶子模块，也可以把两个或多个叶子模块合并到一起进行测试
  •（2）使用驱动模块对步骤１选定的模块（或模块组）进行测试
  •（3）用实际模块代替驱动模块，与它已测试的直属子模块组装成一个更大的模块进行测试
  •（4）重复上面的行为，直到系统最顶层模块被加入到已测系统中

- 三明治增量式测试

  混合式集成，把系统划分成三层，中间一层为目标层，目标层之上采用自顶向下集成，之下采用自底向上集成

  ![image-20220615100739472](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615100739472.png)

  （1）首先对目标层之上一层使用自顶向下集成，因此测试A，使用桩代替B，C，D
  （2）其次对目标层之下一层使用自底向上集成，因此测试E，F，使用驱动代替B，D
  （3）其三，把目标层下面一层与目标层集成，因此测试（B，E），（D，F），使用驱动代替A
  （4）最后，把三层集成到一起，因此测试（A，B，C，D，E，F）

### 软件缺陷数目估计

估计残留软件缺陷数目的方法
•播撒模型
•静态模型
•根据测试覆盖率的预测模型

#### 故障播种

检测到的播种故障数目 / 总的播种故障数目 = 检测到的非播种故障的数目 / 总的非播种故障的数目

![image-20220615101405379](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615101405379.png)

10 / 2 = N / 158  , N =  790

#### 改进

假设软件经过X个月的排错时间，程序中将不再存在错误。那么让两个人共同对程序进行排错，经过足够长(X的一半或更少)的排错时间后，第一个人发现了n个错误，第二个人发现了m个错误，其中属于两个人共同发现的错误有m1个，则程序中的固有错误：

> 按照课本，有两个小组x,y,共同发现q个
>
> 有效性E1 = x/n E2 = y/n  并且  q/y = x/n  推出=>  n = q / (E1*E2)

所以N = m*n / m1

![image-20220615102357612](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615102357612.png)

![image-20220615102412022](https://vvtorres.oss-cn-beijing.aliyuncs.com/image-20220615102412022.png)
